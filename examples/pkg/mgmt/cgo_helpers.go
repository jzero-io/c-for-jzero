// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Tue, 30 Jul 2024 12:57:57 CST.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package mgmt

/*
#cgo CFLAGS: -I.
#include "xengine_mgmt_op.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocXengine_alg_statusMemory allocates memory for type C.xengine_alg_status in C.
// The caller is responsible for freeing the this memory via C.free.
func allocXengine_alg_statusMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfXengine_alg_statusValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfXengine_alg_statusValue = unsafe.Sizeof([1]C.xengine_alg_status{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Xengine_alg_status) Ref() *C.xengine_alg_status {
	if x == nil {
		return nil
	}
	return x.ref32bf029e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Xengine_alg_status) Free() {
	if x != nil && x.allocs32bf029e != nil {
		x.allocs32bf029e.(*cgoAllocMap).Free()
		x.ref32bf029e = nil
	}
}

// NewXengine_alg_statusRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewXengine_alg_statusRef(ref unsafe.Pointer) *Xengine_alg_status {
	if ref == nil {
		return nil
	}
	obj := new(Xengine_alg_status)
	obj.ref32bf029e = (*C.xengine_alg_status)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Xengine_alg_status) PassRef() (*C.xengine_alg_status, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref32bf029e != nil {
		return x.ref32bf029e, nil
	}
	mem32bf029e := allocXengine_alg_statusMemory(1)
	ref32bf029e := (*C.xengine_alg_status)(mem32bf029e)
	allocs32bf029e := new(cgoAllocMap)
	allocs32bf029e.Add(mem32bf029e)

	var crandom_status_allocs *cgoAllocMap
	ref32bf029e.random_status, crandom_status_allocs = (C.int)(x.Random_status), cgoAllocsUnknown
	allocs32bf029e.Borrow(crandom_status_allocs)

	var csoft_alg_status_allocs *cgoAllocMap
	ref32bf029e.soft_alg_status, csoft_alg_status_allocs = (C.int)(x.Soft_alg_status), cgoAllocsUnknown
	allocs32bf029e.Borrow(csoft_alg_status_allocs)

	var cdev_sm4_status_allocs *cgoAllocMap
	ref32bf029e.dev_sm4_status, cdev_sm4_status_allocs = (C.int)(x.Dev_sm4_status), cgoAllocsUnknown
	allocs32bf029e.Borrow(cdev_sm4_status_allocs)

	var cdev_sm3_status_allocs *cgoAllocMap
	ref32bf029e.dev_sm3_status, cdev_sm3_status_allocs = (C.int)(x.Dev_sm3_status), cgoAllocsUnknown
	allocs32bf029e.Borrow(cdev_sm3_status_allocs)

	var cdev_sm9_enc_status_allocs *cgoAllocMap
	ref32bf029e.dev_sm9_enc_status, cdev_sm9_enc_status_allocs = (C.int)(x.Dev_sm9_enc_status), cgoAllocsUnknown
	allocs32bf029e.Borrow(cdev_sm9_enc_status_allocs)

	var cdev_sm9_sign_status_allocs *cgoAllocMap
	ref32bf029e.dev_sm9_sign_status, cdev_sm9_sign_status_allocs = (C.int)(x.Dev_sm9_sign_status), cgoAllocsUnknown
	allocs32bf029e.Borrow(cdev_sm9_sign_status_allocs)

	var cdev_sm2_enc_status_allocs *cgoAllocMap
	ref32bf029e.dev_sm2_enc_status, cdev_sm2_enc_status_allocs = (C.int)(x.Dev_sm2_enc_status), cgoAllocsUnknown
	allocs32bf029e.Borrow(cdev_sm2_enc_status_allocs)

	var cdev_sm2_sign_status_allocs *cgoAllocMap
	ref32bf029e.dev_sm2_sign_status, cdev_sm2_sign_status_allocs = (C.int)(x.Dev_sm2_sign_status), cgoAllocsUnknown
	allocs32bf029e.Borrow(cdev_sm2_sign_status_allocs)

	var ccard_sm2_enc_status_allocs *cgoAllocMap
	ref32bf029e.card_sm2_enc_status, ccard_sm2_enc_status_allocs = (C.int)(x.Card_sm2_enc_status), cgoAllocsUnknown
	allocs32bf029e.Borrow(ccard_sm2_enc_status_allocs)

	var ccard_sm2_sign_status_allocs *cgoAllocMap
	ref32bf029e.card_sm2_sign_status, ccard_sm2_sign_status_allocs = (C.int)(x.Card_sm2_sign_status), cgoAllocsUnknown
	allocs32bf029e.Borrow(ccard_sm2_sign_status_allocs)

	var cusb_status_allocs *cgoAllocMap
	ref32bf029e.usb_status, cusb_status_allocs = (C.int)(x.Usb_status), cgoAllocsUnknown
	allocs32bf029e.Borrow(cusb_status_allocs)

	var creserved_allocs *cgoAllocMap
	ref32bf029e.reserved, creserved_allocs = *(*[60]C.uchar)(unsafe.Pointer(&x.Reserved)), cgoAllocsUnknown
	allocs32bf029e.Borrow(creserved_allocs)

	x.ref32bf029e = ref32bf029e
	x.allocs32bf029e = allocs32bf029e
	return ref32bf029e, allocs32bf029e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Xengine_alg_status) PassValue() (C.xengine_alg_status, *cgoAllocMap) {
	if x.ref32bf029e != nil {
		return *x.ref32bf029e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Xengine_alg_status) Deref() {
	if x.ref32bf029e == nil {
		return
	}
	x.Random_status = (int32)(x.ref32bf029e.random_status)
	x.Soft_alg_status = (int32)(x.ref32bf029e.soft_alg_status)
	x.Dev_sm4_status = (int32)(x.ref32bf029e.dev_sm4_status)
	x.Dev_sm3_status = (int32)(x.ref32bf029e.dev_sm3_status)
	x.Dev_sm9_enc_status = (int32)(x.ref32bf029e.dev_sm9_enc_status)
	x.Dev_sm9_sign_status = (int32)(x.ref32bf029e.dev_sm9_sign_status)
	x.Dev_sm2_enc_status = (int32)(x.ref32bf029e.dev_sm2_enc_status)
	x.Dev_sm2_sign_status = (int32)(x.ref32bf029e.dev_sm2_sign_status)
	x.Card_sm2_enc_status = (int32)(x.ref32bf029e.card_sm2_enc_status)
	x.Card_sm2_sign_status = (int32)(x.ref32bf029e.card_sm2_sign_status)
	x.Usb_status = (int32)(x.ref32bf029e.usb_status)
	x.Reserved = *(*[60]byte)(unsafe.Pointer(&x.ref32bf029e.reserved))
}

// allocXengine_device_cfgMemory allocates memory for type C.xengine_device_cfg in C.
// The caller is responsible for freeing the this memory via C.free.
func allocXengine_device_cfgMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfXengine_device_cfgValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfXengine_device_cfgValue = unsafe.Sizeof([1]C.xengine_device_cfg{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Xengine_device_cfg) Ref() *C.xengine_device_cfg {
	if x == nil {
		return nil
	}
	return x.ref2f69cd7d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Xengine_device_cfg) Free() {
	if x != nil && x.allocs2f69cd7d != nil {
		x.allocs2f69cd7d.(*cgoAllocMap).Free()
		x.ref2f69cd7d = nil
	}
}

// NewXengine_device_cfgRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewXengine_device_cfgRef(ref unsafe.Pointer) *Xengine_device_cfg {
	if ref == nil {
		return nil
	}
	obj := new(Xengine_device_cfg)
	obj.ref2f69cd7d = (*C.xengine_device_cfg)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Xengine_device_cfg) PassRef() (*C.xengine_device_cfg, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2f69cd7d != nil {
		return x.ref2f69cd7d, nil
	}
	mem2f69cd7d := allocXengine_device_cfgMemory(1)
	ref2f69cd7d := (*C.xengine_device_cfg)(mem2f69cd7d)
	allocs2f69cd7d := new(cgoAllocMap)
	allocs2f69cd7d.Add(mem2f69cd7d)

	var cmax_key_num_allocs *cgoAllocMap
	ref2f69cd7d.max_key_num, cmax_key_num_allocs = (C.int)(x.Max_key_num), cgoAllocsUnknown
	allocs2f69cd7d.Borrow(cmax_key_num_allocs)

	var cdevice_config_allocs *cgoAllocMap
	ref2f69cd7d.device_config, cdevice_config_allocs = (C.uint)(x.Device_config), cgoAllocsUnknown
	allocs2f69cd7d.Borrow(cdevice_config_allocs)

	var creserved_allocs *cgoAllocMap
	ref2f69cd7d.reserved, creserved_allocs = *(*[504]C.uchar)(unsafe.Pointer(&x.Reserved)), cgoAllocsUnknown
	allocs2f69cd7d.Borrow(creserved_allocs)

	x.ref2f69cd7d = ref2f69cd7d
	x.allocs2f69cd7d = allocs2f69cd7d
	return ref2f69cd7d, allocs2f69cd7d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Xengine_device_cfg) PassValue() (C.xengine_device_cfg, *cgoAllocMap) {
	if x.ref2f69cd7d != nil {
		return *x.ref2f69cd7d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Xengine_device_cfg) Deref() {
	if x.ref2f69cd7d == nil {
		return
	}
	x.Max_key_num = (int32)(x.ref2f69cd7d.max_key_num)
	x.Device_config = (uint32)(x.ref2f69cd7d.device_config)
	x.Reserved = *(*[504]byte)(unsafe.Pointer(&x.ref2f69cd7d.reserved))
}

// allocXEngineLicense_tMemory allocates memory for type C.XEngineLicense_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocXEngineLicense_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfXEngineLicense_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfXEngineLicense_tValue = unsafe.Sizeof([1]C.XEngineLicense_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *XEngineLicense_t) Ref() *C.XEngineLicense_t {
	if x == nil {
		return nil
	}
	return x.ref7466438d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *XEngineLicense_t) Free() {
	if x != nil && x.allocs7466438d != nil {
		x.allocs7466438d.(*cgoAllocMap).Free()
		x.ref7466438d = nil
	}
}

// NewXEngineLicense_tRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewXEngineLicense_tRef(ref unsafe.Pointer) *XEngineLicense_t {
	if ref == nil {
		return nil
	}
	obj := new(XEngineLicense_t)
	obj.ref7466438d = (*C.XEngineLicense_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *XEngineLicense_t) PassRef() (*C.XEngineLicense_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7466438d != nil {
		return x.ref7466438d, nil
	}
	mem7466438d := allocXEngineLicense_tMemory(1)
	ref7466438d := (*C.XEngineLicense_t)(mem7466438d)
	allocs7466438d := new(cgoAllocMap)
	allocs7466438d.Add(mem7466438d)

	var cnVer_allocs *cgoAllocMap
	ref7466438d.nVer, cnVer_allocs = (C.uint)(x.NVer), cgoAllocsUnknown
	allocs7466438d.Borrow(cnVer_allocs)

	var cnKeyIndex_allocs *cgoAllocMap
	ref7466438d.nKeyIndex, cnKeyIndex_allocs = (C.uint)(x.NKeyIndex), cgoAllocsUnknown
	allocs7466438d.Borrow(cnKeyIndex_allocs)

	var cnOp_allocs *cgoAllocMap
	ref7466438d.nOp, cnOp_allocs = (C.uint)(x.NOp), cgoAllocsUnknown
	allocs7466438d.Borrow(cnOp_allocs)

	var cnLicenseIndex_allocs *cgoAllocMap
	ref7466438d.nLicenseIndex, cnLicenseIndex_allocs = *(*[8]C.uchar)(unsafe.Pointer(&x.NLicenseIndex)), cgoAllocsUnknown
	allocs7466438d.Borrow(cnLicenseIndex_allocs)

	var cnSeq_allocs *cgoAllocMap
	ref7466438d.nSeq, cnSeq_allocs = (C.uint)(x.NSeq), cgoAllocsUnknown
	allocs7466438d.Borrow(cnSeq_allocs)

	var cnTotalNum_allocs *cgoAllocMap
	ref7466438d.nTotalNum, cnTotalNum_allocs = (C.uint)(x.NTotalNum), cgoAllocsUnknown
	allocs7466438d.Borrow(cnTotalNum_allocs)

	var cnIncreasement_allocs *cgoAllocMap
	ref7466438d.nIncreasement, cnIncreasement_allocs = (C.uint)(x.NIncreasement), cgoAllocsUnknown
	allocs7466438d.Borrow(cnIncreasement_allocs)

	var cucRandom_allocs *cgoAllocMap
	ref7466438d.ucRandom, cucRandom_allocs = *(*[20]C.uchar)(unsafe.Pointer(&x.UcRandom)), cgoAllocsUnknown
	allocs7466438d.Borrow(cucRandom_allocs)

	var cucMagic_allocs *cgoAllocMap
	ref7466438d.ucMagic, cucMagic_allocs = *(*[20]C.uchar)(unsafe.Pointer(&x.UcMagic)), cgoAllocsUnknown
	allocs7466438d.Borrow(cucMagic_allocs)

	x.ref7466438d = ref7466438d
	x.allocs7466438d = allocs7466438d
	return ref7466438d, allocs7466438d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x XEngineLicense_t) PassValue() (C.XEngineLicense_t, *cgoAllocMap) {
	if x.ref7466438d != nil {
		return *x.ref7466438d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *XEngineLicense_t) Deref() {
	if x.ref7466438d == nil {
		return
	}
	x.NVer = (uint32)(x.ref7466438d.nVer)
	x.NKeyIndex = (uint32)(x.ref7466438d.nKeyIndex)
	x.NOp = (uint32)(x.ref7466438d.nOp)
	x.NLicenseIndex = *(*[8]byte)(unsafe.Pointer(&x.ref7466438d.nLicenseIndex))
	x.NSeq = (uint32)(x.ref7466438d.nSeq)
	x.NTotalNum = (uint32)(x.ref7466438d.nTotalNum)
	x.NIncreasement = (uint32)(x.ref7466438d.nIncreasement)
	x.UcRandom = *(*[20]byte)(unsafe.Pointer(&x.ref7466438d.ucRandom))
	x.UcMagic = *(*[20]byte)(unsafe.Pointer(&x.ref7466438d.ucMagic))
}

// allocXEngineDevLicense_tMemory allocates memory for type C.XEngineDevLicense_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocXEngineDevLicense_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfXEngineDevLicense_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfXEngineDevLicense_tValue = unsafe.Sizeof([1]C.XEngineDevLicense_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *XEngineDevLicense_t) Ref() *C.XEngineDevLicense_t {
	if x == nil {
		return nil
	}
	return x.refc230d25e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *XEngineDevLicense_t) Free() {
	if x != nil && x.allocsc230d25e != nil {
		x.allocsc230d25e.(*cgoAllocMap).Free()
		x.refc230d25e = nil
	}
}

// NewXEngineDevLicense_tRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewXEngineDevLicense_tRef(ref unsafe.Pointer) *XEngineDevLicense_t {
	if ref == nil {
		return nil
	}
	obj := new(XEngineDevLicense_t)
	obj.refc230d25e = (*C.XEngineDevLicense_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *XEngineDevLicense_t) PassRef() (*C.XEngineDevLicense_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc230d25e != nil {
		return x.refc230d25e, nil
	}
	memc230d25e := allocXEngineDevLicense_tMemory(1)
	refc230d25e := (*C.XEngineDevLicense_t)(memc230d25e)
	allocsc230d25e := new(cgoAllocMap)
	allocsc230d25e.Add(memc230d25e)

	var cnVer_allocs *cgoAllocMap
	refc230d25e.nVer, cnVer_allocs = (C.uint)(x.NVer), cgoAllocsUnknown
	allocsc230d25e.Borrow(cnVer_allocs)

	var cnType_allocs *cgoAllocMap
	refc230d25e.nType, cnType_allocs = (C.uint)(x.NType), cgoAllocsUnknown
	allocsc230d25e.Borrow(cnType_allocs)

	var cnIssueTime_allocs *cgoAllocMap
	refc230d25e.nIssueTime, cnIssueTime_allocs = (C.ulonglong)(x.NIssueTime), cgoAllocsUnknown
	allocsc230d25e.Borrow(cnIssueTime_allocs)

	var cnStartTime_allocs *cgoAllocMap
	refc230d25e.nStartTime, cnStartTime_allocs = (C.ulonglong)(x.NStartTime), cgoAllocsUnknown
	allocsc230d25e.Borrow(cnStartTime_allocs)

	var cnDeadTime_allocs *cgoAllocMap
	refc230d25e.nDeadTime, cnDeadTime_allocs = (C.ulonglong)(x.NDeadTime), cgoAllocsUnknown
	allocsc230d25e.Borrow(cnDeadTime_allocs)

	var cnSeq_allocs *cgoAllocMap
	refc230d25e.nSeq, cnSeq_allocs = (C.uint)(x.NSeq), cgoAllocsUnknown
	allocsc230d25e.Borrow(cnSeq_allocs)

	var cucSeqNum_allocs *cgoAllocMap
	refc230d25e.ucSeqNum, cucSeqNum_allocs = *(*[8]C.uchar)(unsafe.Pointer(&x.UcSeqNum)), cgoAllocsUnknown
	allocsc230d25e.Borrow(cucSeqNum_allocs)

	var cucUser_allocs *cgoAllocMap
	refc230d25e.ucUser, cucUser_allocs = *(*[8]C.uchar)(unsafe.Pointer(&x.UcUser)), cgoAllocsUnknown
	allocsc230d25e.Borrow(cucUser_allocs)

	var cucIssuer_allocs *cgoAllocMap
	refc230d25e.ucIssuer, cucIssuer_allocs = *(*[8]C.uchar)(unsafe.Pointer(&x.UcIssuer)), cgoAllocsUnknown
	allocsc230d25e.Borrow(cucIssuer_allocs)

	var cucDevId_allocs *cgoAllocMap
	refc230d25e.ucDevId, cucDevId_allocs = *(*[32]C.uchar)(unsafe.Pointer(&x.UcDevId)), cgoAllocsUnknown
	allocsc230d25e.Borrow(cucDevId_allocs)

	var cucMagic_allocs *cgoAllocMap
	refc230d25e.ucMagic, cucMagic_allocs = *(*[20]C.uchar)(unsafe.Pointer(&x.UcMagic)), cgoAllocsUnknown
	allocsc230d25e.Borrow(cucMagic_allocs)

	x.refc230d25e = refc230d25e
	x.allocsc230d25e = allocsc230d25e
	return refc230d25e, allocsc230d25e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x XEngineDevLicense_t) PassValue() (C.XEngineDevLicense_t, *cgoAllocMap) {
	if x.refc230d25e != nil {
		return *x.refc230d25e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *XEngineDevLicense_t) Deref() {
	if x.refc230d25e == nil {
		return
	}
	x.NVer = (uint32)(x.refc230d25e.nVer)
	x.NType = (uint32)(x.refc230d25e.nType)
	x.NIssueTime = (uint64)(x.refc230d25e.nIssueTime)
	x.NStartTime = (uint64)(x.refc230d25e.nStartTime)
	x.NDeadTime = (uint64)(x.refc230d25e.nDeadTime)
	x.NSeq = (uint32)(x.refc230d25e.nSeq)
	x.UcSeqNum = *(*[8]byte)(unsafe.Pointer(&x.refc230d25e.ucSeqNum))
	x.UcUser = *(*[8]byte)(unsafe.Pointer(&x.refc230d25e.ucUser))
	x.UcIssuer = *(*[8]byte)(unsafe.Pointer(&x.refc230d25e.ucIssuer))
	x.UcDevId = *(*[32]byte)(unsafe.Pointer(&x.refc230d25e.ucDevId))
	x.UcMagic = *(*[20]byte)(unsafe.Pointer(&x.refc230d25e.ucMagic))
}

// allocXEngineKeyInfo_tMemory allocates memory for type C.XEngineKeyInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocXEngineKeyInfo_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfXEngineKeyInfo_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfXEngineKeyInfo_tValue = unsafe.Sizeof([1]C.XEngineKeyInfo_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *XEngineKeyInfo_t) Ref() *C.XEngineKeyInfo_t {
	if x == nil {
		return nil
	}
	return x.ref9e381fbd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *XEngineKeyInfo_t) Free() {
	if x != nil && x.allocs9e381fbd != nil {
		x.allocs9e381fbd.(*cgoAllocMap).Free()
		x.ref9e381fbd = nil
	}
}

// NewXEngineKeyInfo_tRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewXEngineKeyInfo_tRef(ref unsafe.Pointer) *XEngineKeyInfo_t {
	if ref == nil {
		return nil
	}
	obj := new(XEngineKeyInfo_t)
	obj.ref9e381fbd = (*C.XEngineKeyInfo_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *XEngineKeyInfo_t) PassRef() (*C.XEngineKeyInfo_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9e381fbd != nil {
		return x.ref9e381fbd, nil
	}
	mem9e381fbd := allocXEngineKeyInfo_tMemory(1)
	ref9e381fbd := (*C.XEngineKeyInfo_t)(mem9e381fbd)
	allocs9e381fbd := new(cgoAllocMap)
	allocs9e381fbd.Add(mem9e381fbd)

	var cbUsed_allocs *cgoAllocMap
	ref9e381fbd.bUsed, cbUsed_allocs = (C.uchar)(x.BUsed), cgoAllocsUnknown
	allocs9e381fbd.Borrow(cbUsed_allocs)

	var ccAlg_allocs *cgoAllocMap
	ref9e381fbd.cAlg, ccAlg_allocs = (C.uchar)(x.CAlg), cgoAllocsUnknown
	allocs9e381fbd.Borrow(ccAlg_allocs)

	var cbPub_allocs *cgoAllocMap
	ref9e381fbd.bPub, cbPub_allocs = (C.uchar)(x.BPub), cgoAllocsUnknown
	allocs9e381fbd.Borrow(cbPub_allocs)

	var cbPrv_allocs *cgoAllocMap
	ref9e381fbd.bPrv, cbPrv_allocs = (C.uchar)(x.BPrv), cgoAllocsUnknown
	allocs9e381fbd.Borrow(cbPrv_allocs)

	var cnBits_allocs *cgoAllocMap
	ref9e381fbd.nBits, cnBits_allocs = (C.uint)(x.NBits), cgoAllocsUnknown
	allocs9e381fbd.Borrow(cnBits_allocs)

	x.ref9e381fbd = ref9e381fbd
	x.allocs9e381fbd = allocs9e381fbd
	return ref9e381fbd, allocs9e381fbd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x XEngineKeyInfo_t) PassValue() (C.XEngineKeyInfo_t, *cgoAllocMap) {
	if x.ref9e381fbd != nil {
		return *x.ref9e381fbd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *XEngineKeyInfo_t) Deref() {
	if x.ref9e381fbd == nil {
		return
	}
	x.BUsed = (byte)(x.ref9e381fbd.bUsed)
	x.CAlg = (byte)(x.ref9e381fbd.cAlg)
	x.BPub = (byte)(x.ref9e381fbd.bPub)
	x.BPrv = (byte)(x.ref9e381fbd.bPrv)
	x.NBits = (uint32)(x.ref9e381fbd.nBits)
}

// allocXEngineKeyInfoEx_tMemory allocates memory for type C.XEngineKeyInfoEx_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocXEngineKeyInfoEx_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfXEngineKeyInfoEx_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfXEngineKeyInfoEx_tValue = unsafe.Sizeof([1]C.XEngineKeyInfoEx_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *XEngineKeyInfoEx_t) Ref() *C.XEngineKeyInfoEx_t {
	if x == nil {
		return nil
	}
	return x.refc14febe6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *XEngineKeyInfoEx_t) Free() {
	if x != nil && x.allocsc14febe6 != nil {
		x.allocsc14febe6.(*cgoAllocMap).Free()
		x.refc14febe6 = nil
	}
}

// NewXEngineKeyInfoEx_tRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewXEngineKeyInfoEx_tRef(ref unsafe.Pointer) *XEngineKeyInfoEx_t {
	if ref == nil {
		return nil
	}
	obj := new(XEngineKeyInfoEx_t)
	obj.refc14febe6 = (*C.XEngineKeyInfoEx_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *XEngineKeyInfoEx_t) PassRef() (*C.XEngineKeyInfoEx_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc14febe6 != nil {
		return x.refc14febe6, nil
	}
	memc14febe6 := allocXEngineKeyInfoEx_tMemory(1)
	refc14febe6 := (*C.XEngineKeyInfoEx_t)(memc14febe6)
	allocsc14febe6 := new(cgoAllocMap)
	allocsc14febe6.Add(memc14febe6)

	var cbUsed_allocs *cgoAllocMap
	refc14febe6.bUsed, cbUsed_allocs = (C.uchar)(x.BUsed), cgoAllocsUnknown
	allocsc14febe6.Borrow(cbUsed_allocs)

	var ccAlg_allocs *cgoAllocMap
	refc14febe6.cAlg, ccAlg_allocs = (C.uchar)(x.CAlg), cgoAllocsUnknown
	allocsc14febe6.Borrow(ccAlg_allocs)

	var cbPub_allocs *cgoAllocMap
	refc14febe6.bPub, cbPub_allocs = (C.uchar)(x.BPub), cgoAllocsUnknown
	allocsc14febe6.Borrow(cbPub_allocs)

	var cbPrv_allocs *cgoAllocMap
	refc14febe6.bPrv, cbPrv_allocs = (C.uchar)(x.BPrv), cgoAllocsUnknown
	allocsc14febe6.Borrow(cbPrv_allocs)

	var cnBits_allocs *cgoAllocMap
	refc14febe6.nBits, cnBits_allocs = (C.uint)(x.NBits), cgoAllocsUnknown
	allocsc14febe6.Borrow(cnBits_allocs)

	var cbKeyId_allocs *cgoAllocMap
	refc14febe6.bKeyId, cbKeyId_allocs = *(*[192]C.uchar)(unsafe.Pointer(&x.BKeyId)), cgoAllocsUnknown
	allocsc14febe6.Borrow(cbKeyId_allocs)

	x.refc14febe6 = refc14febe6
	x.allocsc14febe6 = allocsc14febe6
	return refc14febe6, allocsc14febe6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x XEngineKeyInfoEx_t) PassValue() (C.XEngineKeyInfoEx_t, *cgoAllocMap) {
	if x.refc14febe6 != nil {
		return *x.refc14febe6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *XEngineKeyInfoEx_t) Deref() {
	if x.refc14febe6 == nil {
		return
	}
	x.BUsed = (byte)(x.refc14febe6.bUsed)
	x.CAlg = (byte)(x.refc14febe6.cAlg)
	x.BPub = (byte)(x.refc14febe6.bPub)
	x.BPrv = (byte)(x.refc14febe6.bPrv)
	x.NBits = (uint32)(x.refc14febe6.nBits)
	x.BKeyId = *(*[192]byte)(unsafe.Pointer(&x.refc14febe6.bKeyId))
}

// allocXENGINE_MgmtPasswd_tMemory allocates memory for type C.XENGINE_MgmtPasswd_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocXENGINE_MgmtPasswd_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfXENGINE_MgmtPasswd_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfXENGINE_MgmtPasswd_tValue = unsafe.Sizeof([1]C.XENGINE_MgmtPasswd_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *XENGINE_MgmtPasswd_t) Ref() *C.XENGINE_MgmtPasswd_t {
	if x == nil {
		return nil
	}
	return x.ref1380ca00
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *XENGINE_MgmtPasswd_t) Free() {
	if x != nil && x.allocs1380ca00 != nil {
		x.allocs1380ca00.(*cgoAllocMap).Free()
		x.ref1380ca00 = nil
	}
}

// NewXENGINE_MgmtPasswd_tRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewXENGINE_MgmtPasswd_tRef(ref unsafe.Pointer) *XENGINE_MgmtPasswd_t {
	if ref == nil {
		return nil
	}
	obj := new(XENGINE_MgmtPasswd_t)
	obj.ref1380ca00 = (*C.XENGINE_MgmtPasswd_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *XENGINE_MgmtPasswd_t) PassRef() (*C.XENGINE_MgmtPasswd_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1380ca00 != nil {
		return x.ref1380ca00, nil
	}
	mem1380ca00 := allocXENGINE_MgmtPasswd_tMemory(1)
	ref1380ca00 := (*C.XENGINE_MgmtPasswd_t)(mem1380ca00)
	allocs1380ca00 := new(cgoAllocMap)
	allocs1380ca00.Add(mem1380ca00)

	var cnLen_allocs *cgoAllocMap
	ref1380ca00.nLen, cnLen_allocs = (C.int)(x.NLen), cgoAllocsUnknown
	allocs1380ca00.Borrow(cnLen_allocs)

	var cpPasswd_allocs *cgoAllocMap
	ref1380ca00.pPasswd, cpPasswd_allocs = *(*[64]C.uchar)(unsafe.Pointer(&x.PPasswd)), cgoAllocsUnknown
	allocs1380ca00.Borrow(cpPasswd_allocs)

	x.ref1380ca00 = ref1380ca00
	x.allocs1380ca00 = allocs1380ca00
	return ref1380ca00, allocs1380ca00

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x XENGINE_MgmtPasswd_t) PassValue() (C.XENGINE_MgmtPasswd_t, *cgoAllocMap) {
	if x.ref1380ca00 != nil {
		return *x.ref1380ca00, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *XENGINE_MgmtPasswd_t) Deref() {
	if x.ref1380ca00 == nil {
		return
	}
	x.NLen = (int32)(x.ref1380ca00.nLen)
	x.PPasswd = *(*[64]byte)(unsafe.Pointer(&x.ref1380ca00.pPasswd))
}

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

// copyPCharBytes copies the data from Go slice as *C.char.
func copyPCharBytes(slice *sliceHeader) (*C.char, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfCharValue) * slice.Len,
		Cap:  int(sizeOfCharValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.char)(mem0), allocs
}

// allocCharMemory allocates memory for type C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCharValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCharValue = unsafe.Sizeof([1]C.char{})

// copyPPointerBytes copies the data from Go slice as *unsafe.Pointer.
func copyPPointerBytes(slice *sliceHeader) (*unsafe.Pointer, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfPointerValue) * slice.Len,
		Cap:  int(sizeOfPointerValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*unsafe.Pointer)(mem0), allocs
}

// allocPointerMemory allocates memory for type unsafe.Pointer in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPointerMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPointerValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPointerValue = unsafe.Sizeof([1]unsafe.Pointer{})

// copyPUcharBytes copies the data from Go slice as *C.uchar.
func copyPUcharBytes(slice *sliceHeader) (*C.uchar, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfUcharValue) * slice.Len,
		Cap:  int(sizeOfUcharValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.uchar)(mem0), allocs
}

// allocUcharMemory allocates memory for type C.uchar in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUcharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUcharValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUcharValue = unsafe.Sizeof([1]C.uchar{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackArgSXEngineKeyInfo_t transforms a sliced Go data structure into plain C format.
func unpackArgSXEngineKeyInfo_t(x []XEngineKeyInfo_t) (unpacked *C.XEngineKeyInfo_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocXEngineKeyInfo_tMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.XEngineKeyInfo_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.XEngineKeyInfo_t)(h.Data)
	return
}

// packSXEngineKeyInfo_t reads sliced Go data structure out from plain C format.
func packSXEngineKeyInfo_t(v []XEngineKeyInfo_t, ptr0 *C.XEngineKeyInfo_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfXEngineKeyInfo_tValue]C.XEngineKeyInfo_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewXEngineKeyInfo_tRef(unsafe.Pointer(&ptr1))
	}
}

// copyPUintBytes copies the data from Go slice as *C.uint.
func copyPUintBytes(slice *sliceHeader) (*C.uint, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfUintValue) * slice.Len,
		Cap:  int(sizeOfUintValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.uint)(mem0), allocs
}

// allocUintMemory allocates memory for type C.uint in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUintMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUintValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUintValue = unsafe.Sizeof([1]C.uint{})

// unpackArgSXEngineKeyInfoEx_t transforms a sliced Go data structure into plain C format.
func unpackArgSXEngineKeyInfoEx_t(x []XEngineKeyInfoEx_t) (unpacked *C.XEngineKeyInfoEx_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocXEngineKeyInfoEx_tMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.XEngineKeyInfoEx_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.XEngineKeyInfoEx_t)(h.Data)
	return
}

// packSXEngineKeyInfoEx_t reads sliced Go data structure out from plain C format.
func packSXEngineKeyInfoEx_t(v []XEngineKeyInfoEx_t, ptr0 *C.XEngineKeyInfoEx_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfXEngineKeyInfoEx_tValue]C.XEngineKeyInfoEx_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewXEngineKeyInfoEx_tRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSXENGINE_MgmtPasswd_t transforms a sliced Go data structure into plain C format.
func unpackArgSXENGINE_MgmtPasswd_t(x []XENGINE_MgmtPasswd_t) (unpacked *C.XENGINE_MgmtPasswd_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocXENGINE_MgmtPasswd_tMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.XENGINE_MgmtPasswd_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.XENGINE_MgmtPasswd_t)(h.Data)
	return
}

// packSXENGINE_MgmtPasswd_t reads sliced Go data structure out from plain C format.
func packSXENGINE_MgmtPasswd_t(v []XENGINE_MgmtPasswd_t, ptr0 *C.XENGINE_MgmtPasswd_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfXENGINE_MgmtPasswd_tValue]C.XENGINE_MgmtPasswd_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewXENGINE_MgmtPasswd_tRef(unsafe.Pointer(&ptr1))
	}
}
